{
  "name": "Oled ui module",
  "tagline": "oled simple driver of a single color oled",
  "body": "﻿oled_ui_module\r\n===\r\n\r\noled_ui_module software framework\r\ncreate by chenty\r\n\r\n\r\n这是我写的一个ui支持库\r\n\r\n协议主要用于 类似 5110 这种单色 8位的 lcd 或 OLED的显示驱动\r\n\r\nui库的设计比较简单 原理是把一个屏幕划分成一个一个的控件 然后挂载不同的控件实现显示以及不同的功能\r\n\r\n去除了和上层以及底层的关联 模块化独立出来 以便移植和使用\r\n\r\n目前实现的控件有3个\r\n\r\nstr\t文本控件\r\nimg \t图片控件\r\nbtn\t按钮控件\r\n\r\n所有的显示控件派生于相同的基类 view\r\n\r\n\tstruct ui_view_param_t\r\n\t{\r\n\t\tstruct ui_view_layout_t layout;\r\n\t\tuint32_t\tflags;\r\n\t};\r\n\r\n控件实现以下方法\r\n\r\n\tstruct ui_view_op_t\r\n\t{\r\n\t\tvsf_err_t \t\t\t(*init)(void *param);\r\n\t\tvsf_err_t \t\t\t(*fini)(void *param);\r\n\t\tstruct ui_view_layout_t* \t(*onlayout)(void *param);\r\n\t\tvsf_err_t \t\t\t(*ondraw)(void *param, struct ui_view_buf_t *viewbuf);\r\n\t\tvsf_err_t\t\t\t(*onfocus)(void *param, uint8_t isfocused);\r\n\t\tvsf_err_t \t\t\t(*onevt)(void *param, uint8_t evt);\r\n\t};\r\n\r\nui库通过调用不同的方法来实现控件的显示 聚焦 点击\r\n\r\nui库的使用方法从下\r\n\r\n首先需要提供的配置参数\r\n\r\n显示区域长度\r\n\r\n\t#define DISP_SIZE_H\t\t128\r\n显示区域行数 对于oled 或者 5510这种单色屏幕\r\n\r\n\t#define DISP_SIZE_V\t\t8\r\n控件最大数量\r\n\r\n\t#define UI_CELL_MAX\t\t20\r\n\r\n按键宏 \r\n菜单键键值\r\n\r\n\t#define KEY_VALUE_MENU\t\t\tKEY_VALUE_KEY0\r\n确定键键值\r\n\r\n\t#define KEY_VALUE_ENTER\t\t\tKEY_VALUE_KEY1\r\n\r\n\r\n\r\n\r\n首先需要定义 ui使用的空间 一般单片机环境 就初始化静态结构体即可\r\n\r\n\tstruct ui_param_t ui;\r\n\r\n这是ui模块提供调用的方法\r\n\r\n\tstruct ui_op_t\r\n\t{\r\n\t\tvsf_err_t \t(*init)(struct ui_param_t *param);\r\n\t\tvsf_err_t \t(*fini)(struct ui_param_t *param);\r\n\t\tvsf_err_t \t(*ondisp)(struct ui_param_t *param, struct vsf_buffer_t *dpbuf);\r\n\t\tvsf_err_t \t(*onkey)(struct ui_param_t *param, uint8_t key);\t\r\n\t\tvsf_err_t\t(*addview)(struct ui_param_t *param, void *view, const struct ui_view_op_t *type);\r\n\t\tvsf_err_t\t(*delview)(struct ui_param_t *param, void *view);\r\n\t};\r\n\r\n\r\n首先需要对ui模块初始化\r\n\t\r\n\tui_op.init(&ui);\r\n\r\n然后ui 模块就可以使用了\r\n这时没有任何控件 所以需要 注册控件给ui模块\r\n控件可以为常量 也可以为变量 为了节省内存 不变的显示内容可以存储在flash里面\r\n\r\n例如 文本控件\r\n\r\n\tconst struct ui_viewstr_param_t bootstring = \r\n\t{\r\n\t\t{0, 6, 128, 2}, UI_VIEW_FLAG_ENABLE,\r\n\t\t\"正在开机\" ,UI_VIEW_STRBIG\r\n\t};\r\n\r\n控件的注册需要提供2个参数 一个是控件本身的结构体 一个是控件的方法 这个地方应该有改进的控件 初期设计是这样做的\r\n\r\n\tui_op.addview(&ui, (void *)&bootstring, &ui_viewstr_op);\r\n\r\n这时控件就注册好了\r\n如何显示出来呢\r\n\r\n需要如下步骤 \r\n首先需要提供一个可以显示区域的内存\r\n通过 ` struct vsf_buffer_t ` 结构体传入\r\n显示内存空间需要安装 0 1 2 3 行顺序排布 （目前）\r\n\r\n每次调用 ` ui_op.ondisp(&ui, &dpbuf);` 会刷新一次显示 在btn 控件中 这个刷新速度就是focus闪烁的速度\r\n\r\n建议用法是 在定时器中循环调用 同时在更新内容时 直接调用\r\n\r\n\r\n出现按键事件是 需要将按键evt 传递给ui模块 ui会自动做出切换focus 或者 调用控件 click事件等操作\r\n\r\n方法是 `ui_op.onkey(&ui, keyvalue);`\r\n\r\n\r\n当界面关闭 或者切换时 有2种方式 一种可以把控件DISABLE 一种是del控件\r\n\r\ndel控件是这样操作的\r\n\r\n\tui_op.delview(&ui, (void *)&bootstring);\r\n\r\n当不需要ui释放内存时调用 \r\n\r\n\tui_op.fini(&ui);\r\n\r\n动态分配的内存ui不会释放需要根据系统环境调用相应的函数释放内存\r\n\r\n控件使用详解见对应Readme\r\n\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}